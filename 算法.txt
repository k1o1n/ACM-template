鸽巢原理：
应用：对于任意正整数n必能找到一个数，它前部分由1组成，后部分由0组成，且一定为n的倍数：
证明：对于n，取出1、11、111、1111、……n+1个数，其中必有数在模n的情况下同余，取出这两个数做差，得到的数必定为n的倍数。

c(n,m)=a(n,m)/m!

优化输入：使用scanf/使用cin加速语句：std：：ios：：sync_with_stdio(0);cin.tie（0）;（tie函数中的0建议用nullptr替换）

[n,2n]必然存在质数
若n≥3，则[n,3n/2]必然存在一个质数

一个非零整数与其相反数做与运算结果是其二进制下最低位的1所对应的值
例子:5&(-5):
00000000000000000000000000000101
&
11111111111111111111111111111011
结果为:
00000000000000000000000000000001
即1

位运算进行移位操作时注意强制转换：
例子：
(long long)1<<50=1125899906842624
1<<50=0
二者是不一样的

a%b=（a+k*b）%b
（a*k）%b=k*（a%b）

欧拉函数：f（x）：小于等于x并且与x互质的数的个数（f（1）=1）
性质：如果gcd（a，b）=1，那么f（a）*f（b）=f（a*b）
若x为奇数，那么f（2n）=f（n）

初等数论四大定理：
费马小定理：如果a是一个整数，p是一个质数，并且整数a不是p的倍数（即a、p互质且p为质数），那么a^p-a是p的倍数（即a^（p-1）≡1（mod p））
威尔逊定理：p可整除(p-1)!+1是p为质数的充要条件
欧拉定理：若gcd（a，x）=1，那么a^f（x）≡1（mod x）
中国剩余定理：假设整数m1,m2, ... ,mn两两互质，则对任意的整数：a1,a2, ... ,an，方程组S有解，并可构造得出。

不进准则：
1、2、3平方不进位，故可以构造平方数：
144、169、961、1004004、10609、9000006000001……
 
快速幂：计算a^b
如果b为偶数：计算(a^(b/2))^2
如果b为奇数：计算a*(a^((b-1)/2))^2

所有偶数位数的回文数都是11的倍数
（回文素数必定是奇数位）

判断矩形：
dfs找到该图形的x,y坐标的最小值,并记录面积s。若（x_max-x_min+1）*（y_max-y_min+1）与s相等，则可以说明为矩形

高效筛法：埃氏筛法、欧拉筛法
欧拉筛法：
#include<iostream>
#include<vector>
using namespace std;
bool arr[50001]{};
vector<int>prime;
int main() {
	for (int q = 2; q <= 50000; ++q) {
		if (!arr[q]) {
			prime.push_back(q);
		}
		for (int i = 0; i < prime.size() && prime[i] * q <= 50000; ++i) {
			arr[prime[i] * q] = true;
			if (!(q % prime[i])) {
				break;
			}
		}
	}
	for (int q = 0; q < prime.size(); ++q) {
		cout << prime[q] << endl;
	}
}

负进制转换：一般步骤与普通进制转换一致，求余出现负数时向商加一再求余数即可（余数负数是向上一位借一的结果）

辗转相除法求最大公约数：
int gcd(int x,int y)
	return(b==0?a:gcd(b,a%b));
推论：若gcd（a，b）=c，则gcd（a/c，b/c）=1

差分操作和前缀和互为逆运算

位运算：
a|b=a&b+a^b

贝祖定理：设多元一次方程：ax+by+cz+……=M
其中a，b，c……为系数，O为所有系数的最大公因数，则若O为M的因子，该方程便有整数解

已知前序遍历与后序遍历，则中序遍历的可能数必为2^n
先序遍历：根左右
后序遍历：左右根
中序遍历：左根右
可知：若先序遍历、后续遍历长度为二时：
先序遍历：根节点
后序遍历：节点根
故此时中序遍历有两种表示：
节点根（右子树为空）
根节点（左子树为空）
例子：先序遍历得字符串a、后序遍历得b，通过以下程序可得到中序遍历的可能数量answer：
long long answer=1;
for(int q=0;q<a.length()-1;++q){
	for(int i=1;i<b.length();++i){
		if(a[q]==b[i]&&a[q+1]==b[i-1]){
			answer*=2;
		}
	}
}
avl二叉平衡树：定义某个节点的平衡因子为左右子树节点数只差，若该节点的平衡因子不在-1~1之间，则需要进行旋转

树的重心：
定义：
如果在树中选择某个节点并删除，这棵树将分为若干棵子树，统计子树节点数并记录最大值。取遍树上所有节点，使此最大值取到最小的节点被称为整个树的重心。
（这里以及下文中的「子树」若无特殊说明都是指无根树的子树，即包括「向上」的那棵子树，并且不包括整棵树自身。）
1、树上所有的点到树的重心的距离之和是最短的，如果有多个重心，那么总距离相等。
2、插入或删除一个点，树的重心的位置最多移动一个单位。
3、若添加一条边连接2棵树，那么新树的重心一定在原来两棵树的重心的路径上。
4、树的重心如果不唯一，则至多有两个，且这两个重心相邻。
5、以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。
6、树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。
7、把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。
8、在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。

图论寻路：
基本思路：
将一级关系用dp[q][i]储存，表示q到i的距离，无法用一级关系表示的，视为无穷大。随后开始进行转移，判断加入新的节点后，路径是否能变小（dp[q][k]+d[k][i]<dp[q][i]）
floyed：多个起点搜索最短路径
dijkstra：单个起点搜索最短路径：搜索一轮之后，将剩下的最小的dp[q][i]标记为最段路径，随后不再需要改变
spfa：
